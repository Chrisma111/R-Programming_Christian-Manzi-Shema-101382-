---
title: "MANZI SHEMA CHRISTIAN"
author: "ID101382"
date: "October 13, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# **Project I: World Population Trend and CO2 Emission**

## **1. Instructions**

* Assignment due date: Sunday, October 12, 2025, at 11:59 am CAT,
* Feel free to discuss, but **don't copy other student's work**,
* Late submission will result in a 10% reduction in total marks,
* This is an individual project. Everyone will submit a html knit markdown file named your_first_and_last_names.html and PDF report named last_names_CO2.pdf.


## **2.Task Context:**

In this dataset project, we are interested in analyzing the relationship between population growth and CO2 emissions. We have data for world population and CO2 emissions. The population dataset contains different features such as county names,population density, population growth rate, population ranking, world population percentage, and so on.

## **3. Task Objectives**
Implementation of data management skills.
* Exploratory data analysis,
* Prepare a dataset for analysis,
* Use visualization tools for population trend,
* Correlation analysis,
* Creating new variable from existing ones.

## **4. Task description**
### **4.1 Downloading data and load them to R studio**
* Load both World Population Dataset and CO2 Emissions Around the World to your R studio.

### **A.Load or import World Population Dataset**

```{r }
library(dplyr)
library(tidyr)
library(dplyr)
library(tinytex)
library(rmarkdown)
library(ggplot2)

# loading world population data set
# Load required package

library(readr)

# Load the CSV file safely with proper encoding
file_path <- "C:/Users/pc/Desktop/REXAM/world_population.csv"

# Read CSV using base R with encoding Windows-1252
world_population <- read.csv(
  file_path,fileEncoding = "Windows-1252",
  check.names = FALSE,  # We'll sanitize names next
  stringsAsFactors = FALSE
)

# Convert all column names to UTF-8 and valid R names

names(world_population) <- make.names(iconv(names(world_population),
              from = "Windows-1252", to = "UTF-8"), unique = TRUE)

# Convert all character columns to UTF-8
world_population[] <- lapply(world_population, function(x) {
  if (is.character(x)) iconv(x, from = "Windows-1252", to = "UTF-8") else x
})

CO2_emission <-read_csv(
  "C:/Users/pc/Desktop/REXAM/CO2_emission.csv",)  
  # Handles special characters
)

# Check the first few rows
head(world_population)

```

## 4.2 Exploratory data analysis##

World Population Dataset display variable names


```{r}
names(world_population)
```
the top 5 rows in population dataset,
```{r}
# the top 5 rows in population dataset
head(world_population,5)
```
```{r}
head(CO2_emission)
```
the top 10 rows in emission dataset,
```{r}
# the top 10 rows in emission dataset
tail(world_population,10)
```
```{r}
tail(CO2_emission)
```
```{r}
# checking data type of my dataset (world population)
class(world_population)
```
```{r}
class(CO2_emission)
```
```{r}
# structure: Displays each variable's type (numeric, character, factor, etc.) and a sampleof the data. 
str(world_population)
```
```{r}
str(CO2_emission)
```
The shape of the dataset [Use dim(), nrow(), and ncol()]:
```{r}
# this code is used returns both rows and columns
dim(world_population)
```
```{r}
dim(CO2_emission)
```
```{r}
# checking duplicate in world population
sum(duplicated(world_population))
```
```{r}
sum(duplicated(CO2_emission))
```
```{r}
# checking missing values in each column
colSums(is.na(world_population))
```
Use box plot to check if there are any outliers in the quantitative variables

```{r}
# checking autlier using boxplot in the quantitative variable
world_population_numeric<-world_population[
  sapply(world_population,is.numeric)]

boxplot(world_population_numeric)
```
```{r}
CO2_emission_numeric<- CO2_emission[sapply(CO2_emission,is.numeric)]
boxplot(CO2_emission_numeric)
```
As the quantitative variables are not on the same scales, we have to normalize them into values between 0 and 1, to make make on the same scales.
```{r}
library(ggplot2)
library(reshape2)

# Select only numeric columns

numeric_info <- world_population[sapply(world_population, is.numeric)]

# Normalize numeric columns (0-1 scaling)

numeric_info_norm <- as.data.frame(lapply(numeric_info, function(x) {(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))}))

# Convert to long format for ggplot
long_data <- melt(numeric_info_norm, variable.name = "Variable", 
                    value.name = "Value")

## No id variables; using all as measure variables
# Create the boxplot

ggplot(long_data, aes(x = Variable, y = Value)) +
geom_boxplot(fill = "green", color = "#eb9555") +
theme_minimal() +
labs(
title = "Normalized Boxplot of World Population Variables", x = "Variables", y = "Normalized Values (0-1)"
) + theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
```{r}
## b. Removal of outliers
# Define a function to remove outliers using the Interquartile Range (IQR) method
World_Population_remove_outliers <- function(x) {
# Step 1: Calculate the first quartile (Q1) - the 25th percentile of the data
Q1 <- quantile(x, 0.25, na.rm = TRUE)
# Step 2: Calculate the third quartile (Q3) - the 75th percentile of the data
Q3 <- quantile(x, 0.75, na.rm = TRUE)
# Step 3: Compute the interquartile range (IQR = Q3 - Q1)
# This shows how spread out the middle 50% of values are
IQR <- Q3 - Q1
# Step 4: Keep only the values within the normal range:
# Values below (Q1 - 1.5 * IQR) or above (Q3 + 1.5 * IQR) are considered outliers
# These extreme values are removed from the result

x[x >= (Q1 - 1.5*IQR) & x <= (Q3 + 1.5*IQR)] }
```

```{r}
# Apply outlier removal to each column
World_Population_quant_without_outliers <- lapply(numeric_info, World_Population_remove_outliers)

```

```{r}
# Reshape data for ggplot
values <- unlist(World_Population_quant_without_outliers) # all numeric values
ind <- rep(names(World_Population_quant_without_outliers),# variable names repeated
sapply(World_Population_quant_without_outliers, length))
World_Population_quant_Final_reshaped <- data.frame(values, ind)# final long-format variable names repeated

```

```{r}
# Create boxplot using ggplot2

ggplot(World_Population_quant_Final_reshaped, aes(x = ind, y = values)) +
geom_boxplot(fill = "skyblue", color = "red") + # boxplot style
theme_minimal() + # clean theme
labs(
title = "Normalized Boxplot of World Population Variables", x = "Variables", y = "Normalized Values (0-1)"
) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
names(world_population)
```
```{r}
World_Population_no_outliers<-select(world_population,Country.Territory,X2022.Population,Growth.Rate)
head(time_var)
```
## 4.3 Generating new Variable by using World Population Dataset

```{r}
# Generating new Variable by using World Population Dataset
exponential_growth <- function(P, r, t) {
Population_2030 <- P * exp(r * t)
return(Population_2030)
}
# adding new variable by using mutate function
population_data <- time_var %>%
mutate(Population_2030 = X2022.Population * exp((Growth.Rate/100) * 8))
head(population_data)
```
## 4.4 Value extraction and plot
Based on 2022 population, extract top ten countries with high population number

```{r}
attach(time_var)
detach(time_var)
top10_countries<-time_var%>%
arrange(desc(X2022.Population))
head(top10_countries,10)
```
```{r}
top10 <-head(top10_countries,10)
top10
```

Use an appropriate graph to present top 10 most populous counties and their population
number during 2022.

```{r}
# Reorder Country.Territory by descending population
top10$Country.Territory <- factor(
top10$Country.Territory, levels = top10$Country.Territory[order(top10$X2022.Population, decreasing = FALSE)]
)
```
# 2. Bar Plot: Top 10 Most Populous Countries in 2022

```{r}
library(scales)
ggplot(top10, aes(x = reorder(Country.Territory,-X2022.Population), 
                  y =X2022.Population)) +
  geom_col(fill = "skyblue") +
theme_minimal() +
  
labs(title = "Top 10 Most Populous Countries in 2022", x= "Country", y= "Population")

```
Show the trend in their population number since 1990-2022 by using appropriate graph.
```{r}
names(world_population)
# Show the trend in their population number since 1990-2022 by using appro priate graph.
world_pop1990_2022<-world_population[,c(
"Country.Territory",
"X1990.Population",
"X2000.Population",
"X2010.Population",
"X2015.Population",
"X2020.Population",
"X2022.Population")]

head(world_pop1990_2022)
```
```{r}
top10_pop1990_2022 <- world_pop1990_2022[world_pop1990_2022$Country %in% c
("Mexico", "Russia", "Bangladesh", "Brazil", "Nigeria","Pakistan","China","India","Unit
ed States","Indonesia" ), ]
top10_pop1990_2022
```
2. Show the trend in their population number since 1990-2022 by using appropriate
graph.

```{r}
# Load library
library(tidyverse)

# Our Dataset
data <- top10_pop1990_2022

# Convert from wide to long format
data_long <- data %>%
pivot_longer(
cols = starts_with("X"), names_to = "Year", values_to = "Population"
) %>%
mutate(Year = as.numeric(gsub("X|\\.Population", "", Year)), Population_Millions = Population / 1e6) # convert to millions
```
```{r}
# Plot population trend

ggplot(data_long, aes(x = Year, y = Population_Millions, color = Country.Territory)) +
geom_line(size = 1.3) + geom_point(size = 2) +
labs(title = "Population Growth Trend (1990-2022)", x = "Year", y = "Population (Millions)", color = "Country") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"), axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom"
)
```

## Emissions Around the World dataset to extract emission of 10 most populous countries. Use an appropriate graph to show their emission trend since 1990-2019.

```{r}
head(CO2_emission)
```
```{r}
top10_CO2_emission <- CO2_emission[CO2_emission$Country.Name %in% c("Mexico", "Bangladesh", "Brazil", "Nigeria","Pakistan","China","India","United States","Indonesia","Russian Federation" ), ]
head(top10_CO2_emission)
```
```{r}
# Load required libraries

library(tidyverse) # includes ggplot2, dplyr, tidyr, etc. 

data <- top10_CO2_emission

# Reshape data from wide to long
data_long <- data %>% tidyr::pivot_longer(
cols = starts_with("X"), names_to = "Year", values_to = "CO2_Emissions") %>%
mutate(Year = as.numeric(sub("X", "", Year)))

# Plot
ggplot(data_long, aes(x = Year, y = CO2_Emissions, color = Country.Name)) +
geom_line(size = 1.2) +
geom_point(size = 2) +
theme_minimal(base_size = 14) +
labs(title = "CO2 Emissions Over Time by Country", x ="Year", y ="CO2 Emissions", color = "Country") +
theme(plot.title = element_text(hjust = 0.5), legend.position = "right")
```
## 4.5 Correlation Analysis 

1. Use the population dataset to find correlations between Area , Density , Growth rate, and World Population Percentage by using both numerical values
and heatmap.

```{r}



```
2. Merge the World Population Dataset and CO2 Emissions Around the World on
country name . After extracting, 2022 population and 2019 CO2 emissions.Using
an appropriate methods(visualization, statistical analysis of numerical values,regression,.), determine the pattern of relationships between population number and CO2 emissions.

```{r}
# Merge datasets on country name
merged_data <- world_population %>%
inner_join(CO2_emission, by = c("Country.Territory" = "Country.Name"))
head(merged_data)
```

```{r}

# extract 2022 population and 2019 CO2 emissions
extract_data <- merged_data[,c("Country.Territory", "X2022.Population","X2019...34")]
head(extract_data)
```
```{r}
colSums(is.na(extract_data))
```
```{r}
extract_clean <- na.omit(extract)
head(extract_clean)
```
```{r}
# Statistical correlation
correlation_value <- cor( extract_clean[["X2022.Population"]], extract_clean[["X2019...34"]], method ="pearson")

print(paste("Correlation between 2022 Population and 2019 CO2 emissions:", round(correlation_value, 3)))

```
The Result show no clear relationship between pop and CO2 emmision

```{r}
# Simple regression model
model<-lm(X2019...34 ~ X2022.Population, data = extract_clean)
summary(model)
```
Since p-value: 0.9163 the relationship is not statistically significant
```{r}
# Step 1: Visualization - Scatter plot with regression line

ggplot(extract_clean, aes(x = X2022.Population, y = X2019...34)) +
geom_point(color = "#eb9534", size = 3, alpha = 0.7) +
geom_smooth(method = "lm", se = TRUE, color = "darkblue", linetype = "dashed") +
theme_minimal(base_size = 12) +
labs(title = "Relationship Between 2022 Population and 2019 CO2 Emissions", 
     x = "Population in 2022", y = "CO2 Emissions in 2019", 
     caption = "Data source: World Population & CO2 Emissions datasets"
) +
scale_x_continuous(labels = scales::comma) +
scale_y_continuous(labels = scales::comma)
```

```{r}
ggplot(extract_clean, aes(x = log10(X2022.Population), y = log10(X2019...34))) +
  
geom_point(color = "#eb9534", size = 3, alpha = 0.7) +
geom_smooth(method = "lm", se = TRUE, color = "darkblue", linetype = "dotted") +
theme_minimal(base_size = 14) +
labs(
title = "Log-Log Relationship Between Population and CO2 Emissions", x = "Log10(Population 2022)", y = "Log10(CO2 Emissions2019)")
```
#4.6 Comparing CO2 Emissions in continents

```{r}
head(merged_data)
```

```{r}
# Load required packages
library(dplyr)
library(ggplot2)
library(readr)

# Step 1: Read the dataset

newdata <- merged_data

# Step 2: Clean and rename relevant columns
renamed_data <- newdata %>%
rename(Country = Country.Territory, Continent = Continent, Population_2022 = X2022.Population, CO2_2019 = X2019...34
)

# Step 3: Remove missing values if any
cleaned_data <- na.omit(newdata)

# Step 4: Summarize total CO2 emissions per continent
continent_summary <- renamed_data %>%
group_by(Continent) %>%
summarise(Total_CO2_2019 = sum(CO2_2019, na.rm = TRUE),
Avg_CO2_per_capita = mean(CO2_2019, na.rm = TRUE), 
Total_Population = sum(Population_2022, na.rm = TRUE)
) %>%
  arrange(desc(Total_CO2_2019))
```

```{r}
# Step 5: Display the summary table
print(continent_summary)

```
```{r}
# Step 6: Create a bar chart comparing continents

ggplot(continent_summary, aes(x = reorder(Continent,Total_CO2_2019), 
                              y = Total_CO2_2019, fill = Continent)) +
geom_bar(stat = "identity") +
labs(title = "Total 2019 CO2 Emissions by Continent", x = "Continent", y = "Total CO2 Emissions (Metric Tons per Capita)") +
theme_minimal() +
theme(legend.position = "none")
```
1. What is
the first continent with high 2019 CO2 emission = Europe 2. What is the third continent
in terms of emitting CO2? What is their total emission(metric tons per capita) = North
America, total emission 3. What is the last continent in terms of emitting CO2? What
their total emission(metric tons per capita)? = South America, total emission

```{r}
colnames(data)
```
```{r}
continent_summary <- renamed_data %>%
group_by(Continent) %>%
summarise(
Total_CO2_2019 = sum(CO2_2019, na.rm = TRUE), Avg_CO2_per_capita = mean(CO2_2019, na.rm = TRUE)
) %>%
arrange(desc(Total_CO2_2019))
print(continent_summary)
```
```{r}

library(dplyr)
library(ggplot2)
# Summarize total CO??? emissions by continent
continent_summary <- renamed_data %>%
group_by(Continent) %>%
summarise(Total_CO2_2019 = sum(CO2_2019, na.rm = TRUE)) %>%
mutate(Percent_CO2 = 100 * Total_CO2_2019 / sum(Total_CO2_2019))
ggplot(continent_summary, aes(x = reorder(Continent, -Total_CO2_2019), y = Total_CO2_2019, fill = Continent)) +
geom_bar(stat = "identity") +
geom_text(aes(label = paste0(round(Percent_CO2, 1), "%")), vjust = -0.5, size = 4) +
labs(
title = "CO2 Emissions by Continent (2019)", x = "Continent", y = "Total CO2 Emissions (metric tons)", fill = "Continent"
) +
theme_minimal()

```


